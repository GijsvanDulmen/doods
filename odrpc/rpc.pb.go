// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: odrpc/rpc.proto

package odrpc

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetDetectorsResponse struct {
	Detectors []*Detector `protobuf:"bytes,1,rep,name=detectors,proto3" json:"detectors,omitempty"`
}

func (m *GetDetectorsResponse) Reset()      { *m = GetDetectorsResponse{} }
func (*GetDetectorsResponse) ProtoMessage() {}
func (*GetDetectorsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{0}
}
func (m *GetDetectorsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDetectorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDetectorsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDetectorsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDetectorsResponse.Merge(m, src)
}
func (m *GetDetectorsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDetectorsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDetectorsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDetectorsResponse proto.InternalMessageInfo

func (m *GetDetectorsResponse) GetDetectors() []*Detector {
	if m != nil {
		return m.Detectors
	}
	return nil
}

type Detector struct {
	// The name for this config
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The name for this config
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Model Name
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// Labels
	Labels []string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
	// The detection width
	Width int32 `protobuf:"varint,5,opt,name=width,proto3" json:"width,omitempty"`
	// The detection height
	Height int32 `protobuf:"varint,6,opt,name=height,proto3" json:"height,omitempty"`
	// The detection channels
	Channels int32 `protobuf:"varint,7,opt,name=channels,proto3" json:"channels,omitempty"`
}

func (m *Detector) Reset()      { *m = Detector{} }
func (*Detector) ProtoMessage() {}
func (*Detector) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{1}
}
func (m *Detector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detector.Merge(m, src)
}
func (m *Detector) XXX_Size() int {
	return m.Size()
}
func (m *Detector) XXX_DiscardUnknown() {
	xxx_messageInfo_Detector.DiscardUnknown(m)
}

var xxx_messageInfo_Detector proto.InternalMessageInfo

func (m *Detector) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Detector) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Detector) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Detector) GetLabels() []string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Detector) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *Detector) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Detector) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

// The Process Request
type DetectRequest struct {
	// The ID for the request.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The ID for the request.
	DetectorName string `protobuf:"bytes,2,opt,name=detector_name,json=detectorName,proto3" json:"detector_name,omitempty"`
	// The image data
	Data Raw `protobuf:"bytes,3,opt,name=data,proto3,casttype=Raw" json:"data"`
	// A filename
	File string `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	// What to detect
	Detect map[string]float32 `protobuf:"bytes,5,rep,name=detect,proto3" json:"detect,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	// Sub regions for detection
	Regions []*DetectRegion `protobuf:"bytes,6,rep,name=regions,proto3" json:"regions,omitempty"`
}

func (m *DetectRequest) Reset()      { *m = DetectRequest{} }
func (*DetectRequest) ProtoMessage() {}
func (*DetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{2}
}
func (m *DetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectRequest.Merge(m, src)
}
func (m *DetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetectRequest proto.InternalMessageInfo

func (m *DetectRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectRequest) GetDetectorName() string {
	if m != nil {
		return m.DetectorName
	}
	return ""
}

func (m *DetectRequest) GetData() Raw {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DetectRequest) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *DetectRequest) GetDetect() map[string]float32 {
	if m != nil {
		return m.Detect
	}
	return nil
}

func (m *DetectRequest) GetRegions() []*DetectRegion {
	if m != nil {
		return m.Regions
	}
	return nil
}

type DetectRegion struct {
	// Coordinates
	Top    float32 `protobuf:"fixed32,1,opt,name=top,proto3" json:"top"`
	Left   float32 `protobuf:"fixed32,2,opt,name=left,proto3" json:"left"`
	Bottom float32 `protobuf:"fixed32,3,opt,name=bottom,proto3" json:"bottom"`
	Right  float32 `protobuf:"fixed32,4,opt,name=right,proto3" json:"right"`
	// What to detect
	Detect map[string]float32 `protobuf:"bytes,5,rep,name=detect,proto3" json:"detect,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed32,2,opt,name=value,proto3"`
	Covers bool               `protobuf:"varint,6,opt,name=covers,proto3" json:"covers,omitempty"`
}

func (m *DetectRegion) Reset()      { *m = DetectRegion{} }
func (*DetectRegion) ProtoMessage() {}
func (*DetectRegion) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{3}
}
func (m *DetectRegion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectRegion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectRegion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectRegion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectRegion.Merge(m, src)
}
func (m *DetectRegion) XXX_Size() int {
	return m.Size()
}
func (m *DetectRegion) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectRegion.DiscardUnknown(m)
}

var xxx_messageInfo_DetectRegion proto.InternalMessageInfo

func (m *DetectRegion) GetTop() float32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *DetectRegion) GetLeft() float32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *DetectRegion) GetBottom() float32 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

func (m *DetectRegion) GetRight() float32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *DetectRegion) GetDetect() map[string]float32 {
	if m != nil {
		return m.Detect
	}
	return nil
}

func (m *DetectRegion) GetCovers() bool {
	if m != nil {
		return m.Covers
	}
	return false
}

// Area for detection
type Detection struct {
	// Coordinates
	Top        float32 `protobuf:"fixed32,1,opt,name=top,proto3" json:"top"`
	Left       float32 `protobuf:"fixed32,2,opt,name=left,proto3" json:"left"`
	Bottom     float32 `protobuf:"fixed32,3,opt,name=bottom,proto3" json:"bottom"`
	Right      float32 `protobuf:"fixed32,4,opt,name=right,proto3" json:"right"`
	Label      string  `protobuf:"bytes,5,opt,name=label,proto3" json:"label"`
	Confidence float32 `protobuf:"fixed32,6,opt,name=confidence,proto3" json:"confidence"`
}

func (m *Detection) Reset()      { *m = Detection{} }
func (*Detection) ProtoMessage() {}
func (*Detection) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{4}
}
func (m *Detection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detection.Merge(m, src)
}
func (m *Detection) XXX_Size() int {
	return m.Size()
}
func (m *Detection) XXX_DiscardUnknown() {
	xxx_messageInfo_Detection.DiscardUnknown(m)
}

var xxx_messageInfo_Detection proto.InternalMessageInfo

func (m *Detection) GetTop() float32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *Detection) GetLeft() float32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *Detection) GetBottom() float32 {
	if m != nil {
		return m.Bottom
	}
	return 0
}

func (m *Detection) GetRight() float32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *Detection) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Detection) GetConfidence() float32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

type DetectResponse struct {
	// The id for the response
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The detected areas
	Detections []*Detection `protobuf:"bytes,2,rep,name=detections,proto3" json:"detections,omitempty"`
	// If there was an error (streaming endpoint only)
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *DetectResponse) Reset()      { *m = DetectResponse{} }
func (*DetectResponse) ProtoMessage() {}
func (*DetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_edafdb9f55df517e, []int{5}
}
func (m *DetectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DetectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DetectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectResponse.Merge(m, src)
}
func (m *DetectResponse) XXX_Size() int {
	return m.Size()
}
func (m *DetectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DetectResponse proto.InternalMessageInfo

func (m *DetectResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DetectResponse) GetDetections() []*Detection {
	if m != nil {
		return m.Detections
	}
	return nil
}

func (m *DetectResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*GetDetectorsResponse)(nil), "odrpc.GetDetectorsResponse")
	proto.RegisterType((*Detector)(nil), "odrpc.Detector")
	proto.RegisterType((*DetectRequest)(nil), "odrpc.DetectRequest")
	proto.RegisterMapType((map[string]float32)(nil), "odrpc.DetectRequest.DetectEntry")
	proto.RegisterType((*DetectRegion)(nil), "odrpc.DetectRegion")
	proto.RegisterMapType((map[string]float32)(nil), "odrpc.DetectRegion.DetectEntry")
	proto.RegisterType((*Detection)(nil), "odrpc.Detection")
	proto.RegisterType((*DetectResponse)(nil), "odrpc.DetectResponse")
}

func init() { proto.RegisterFile("odrpc/rpc.proto", fileDescriptor_edafdb9f55df517e) }

var fileDescriptor_edafdb9f55df517e = []byte{
	// 775 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0xbf, 0x6f, 0xc3, 0x44,
	0x14, 0xce, 0x39, 0x89, 0x93, 0xbc, 0xa6, 0x3f, 0x74, 0x94, 0x62, 0xd2, 0xca, 0x8e, 0xdc, 0x25,
	0xaa, 0x54, 0xbb, 0x2a, 0x03, 0xa5, 0x1b, 0x11, 0x15, 0x1b, 0xc3, 0x21, 0x84, 0xd4, 0x05, 0x39,
	0xf6, 0xc5, 0xb1, 0x48, 0x7c, 0xc6, 0xbe, 0xb4, 0x0a, 0x08, 0x09, 0x31, 0x33, 0x20, 0xb1, 0xb0,
	0xb2, 0x21, 0xfe, 0x12, 0xc6, 0x4a, 0x2c, 0x15, 0x43, 0x44, 0x53, 0x06, 0x94, 0xa9, 0x33, 0x13,
	0xba, 0x1f, 0x6e, 0xd3, 0x28, 0x0b, 0x62, 0x60, 0xb1, 0xef, 0xfb, 0xee, 0xbb, 0xe7, 0xf7, 0x3e,
	0xdf, 0x7b, 0xb0, 0xcb, 0xa2, 0x3c, 0x0b, 0xfd, 0x3c, 0x0b, 0xbd, 0x2c, 0x67, 0x9c, 0xe1, 0xba,
	0x24, 0x3a, 0x47, 0x31, 0x63, 0xf1, 0x98, 0xfa, 0x41, 0x96, 0xf8, 0x41, 0x9a, 0x32, 0x1e, 0xf0,
	0x84, 0xa5, 0x85, 0x12, 0x75, 0x0e, 0xf5, 0xae, 0x44, 0x83, 0xe9, 0xd0, 0xa7, 0x93, 0x8c, 0xcf,
	0xf4, 0xe6, 0x69, 0x9c, 0xf0, 0xd1, 0x74, 0xe0, 0x85, 0x6c, 0xe2, 0xc7, 0x2c, 0x66, 0x2f, 0x2a,
	0x81, 0x24, 0x90, 0x2b, 0x25, 0x77, 0xaf, 0x60, 0xff, 0x43, 0xca, 0x3f, 0xa0, 0x9c, 0x86, 0x9c,
	0xe5, 0x05, 0xa1, 0x45, 0xc6, 0xd2, 0x82, 0xe2, 0x53, 0x68, 0x45, 0x25, 0x69, 0xa1, 0x6e, 0xb5,
	0xb7, 0x75, 0xbe, 0xeb, 0xc9, 0xe4, 0xbc, 0x52, 0x4c, 0x5e, 0x14, 0xee, 0x2f, 0x08, 0x9a, 0x25,
	0x8f, 0x31, 0xd4, 0xd2, 0x60, 0x42, 0x2d, 0xd4, 0x45, 0xbd, 0x16, 0x91, 0x6b, 0xc1, 0xf1, 0x59,
	0x46, 0x2d, 0x43, 0x71, 0x62, 0x8d, 0xf7, 0xa1, 0x3e, 0x61, 0x11, 0x1d, 0x5b, 0x55, 0x49, 0x2a,
	0x80, 0x0f, 0xc0, 0x1c, 0x07, 0x03, 0x3a, 0x2e, 0xac, 0x5a, 0xb7, 0xda, 0x6b, 0x11, 0x8d, 0x84,
	0xfa, 0x36, 0x89, 0xf8, 0xc8, 0xaa, 0x77, 0x51, 0xaf, 0x4e, 0x14, 0x10, 0xea, 0x11, 0x4d, 0xe2,
	0x11, 0xb7, 0x4c, 0x49, 0x6b, 0x84, 0x3b, 0xd0, 0x0c, 0x47, 0x41, 0x9a, 0x8a, 0x38, 0x0d, 0xb9,
	0xf3, 0x8c, 0xdd, 0x9f, 0x0c, 0xd8, 0x56, 0xc9, 0x12, 0xfa, 0xc5, 0x94, 0x16, 0x1c, 0xef, 0x80,
	0x91, 0x44, 0x3a, 0x5f, 0x23, 0x89, 0xf0, 0x31, 0x6c, 0x97, 0xb5, 0x7d, 0x26, 0x4b, 0x51, 0x69,
	0xb7, 0x4b, 0xf2, 0x23, 0x51, 0xd2, 0x31, 0xd4, 0xa2, 0x80, 0x07, 0x32, 0xfb, 0x76, 0x7f, 0x77,
	0x39, 0x77, 0x24, 0xfe, 0x7b, 0xee, 0x54, 0x49, 0x70, 0x4b, 0x24, 0x10, 0x75, 0x0f, 0x93, 0x31,
	0xb5, 0x6a, 0xaa, 0x6e, 0xb1, 0xc6, 0x17, 0x60, 0xaa, 0x40, 0x56, 0x5d, 0x1a, 0xdb, 0x7d, 0x65,
	0xac, 0xce, 0x49, 0xa3, 0xab, 0x94, 0xe7, 0x33, 0xa2, 0xf5, 0xf8, 0x14, 0x1a, 0x39, 0x8d, 0xc5,
	0x55, 0xb0, 0x4c, 0x79, 0xf4, 0x8d, 0xb5, 0xa3, 0x62, 0x8f, 0x94, 0x9a, 0xce, 0x7b, 0xb0, 0xb5,
	0x12, 0x05, 0xef, 0x41, 0xf5, 0x73, 0x3a, 0xd3, 0x65, 0x8a, 0xa5, 0xf0, 0xf4, 0x26, 0x18, 0x4f,
	0x55, 0x7d, 0x06, 0x51, 0xe0, 0xd2, 0xb8, 0x40, 0xee, 0x8f, 0x06, 0xb4, 0x57, 0x83, 0xe2, 0xb7,
	0xa1, 0xca, 0x59, 0x26, 0x0f, 0x1b, 0xfd, 0xc6, 0x72, 0xee, 0x08, 0x48, 0xc4, 0x03, 0x1f, 0x41,
	0x6d, 0x4c, 0x87, 0x5c, 0x05, 0xe9, 0x37, 0x85, 0x11, 0x02, 0x13, 0xf9, 0xc4, 0x2e, 0x98, 0x03,
	0xc6, 0x39, 0x9b, 0x48, 0xa3, 0x8c, 0x3e, 0x2c, 0xe7, 0x8e, 0x66, 0x88, 0x7e, 0x63, 0x07, 0xea,
	0xb9, 0xfc, 0x89, 0x35, 0x29, 0x69, 0x2d, 0xe7, 0x8e, 0x22, 0x88, 0x7a, 0xe1, 0x77, 0xd7, 0x2c,
	0x73, 0x36, 0xd4, 0xbd, 0xd1, 0xb1, 0x03, 0x30, 0x43, 0x76, 0x43, 0xf3, 0x42, 0xde, 0x8f, 0x26,
	0xd1, 0xe8, 0xbf, 0x58, 0xf3, 0x3b, 0x82, 0x96, 0x3a, 0xfb, 0xff, 0xfb, 0xe2, 0x40, 0x5d, 0xb6,
	0x87, 0x6c, 0x8a, 0x96, 0x12, 0x48, 0x82, 0xa8, 0x17, 0xf6, 0x00, 0x42, 0x96, 0x0e, 0x93, 0x88,
	0xa6, 0x21, 0x95, 0x1e, 0x18, 0xfd, 0x9d, 0xe5, 0xdc, 0x59, 0x61, 0xc9, 0xca, 0xda, 0x1d, 0xc1,
	0x4e, 0xe9, 0xa9, 0x9e, 0x04, 0xeb, 0xbd, 0x71, 0x06, 0x10, 0x95, 0xd5, 0x17, 0x96, 0x21, 0x7f,
	0xc7, 0xde, 0xab, 0xdf, 0x21, 0xee, 0xe0, 0x8a, 0x46, 0x58, 0x49, 0xf3, 0x9c, 0xe5, 0x65, 0x9f,
	0x4b, 0x70, 0xfe, 0x9d, 0x01, 0x6a, 0xda, 0xe1, 0x4f, 0xa1, 0xbd, 0x3a, 0x83, 0xf0, 0x81, 0xa7,
	0x06, 0x9c, 0x57, 0x8e, 0x2e, 0xef, 0x4a, 0x0c, 0xb8, 0xce, 0xa1, 0xfe, 0xca, 0xa6, 0x81, 0xe5,
	0xe2, 0x6f, 0x7f, 0xfb, 0xf3, 0x07, 0xa3, 0x8d, 0xc1, 0x7f, 0x9e, 0x4a, 0x38, 0x06, 0x53, 0x09,
	0xf1, 0xfe, 0xa6, 0x16, 0xeb, 0xbc, 0xb9, 0xc6, 0xea, 0x50, 0x67, 0x32, 0xd4, 0x89, 0xdb, 0xd0,
	0xa1, 0x2e, 0xd1, 0xc9, 0xf5, 0x91, 0xfb, 0x96, 0x46, 0xfe, 0x57, 0xaf, 0x46, 0xc3, 0xd7, 0x97,
	0xe8, 0x04, 0xbf, 0x5f, 0x36, 0xcb, 0xc7, 0x3c, 0xa7, 0xc1, 0xe4, 0xdf, 0x7d, 0xae, 0xd2, 0x43,
	0x67, 0xa8, 0xff, 0xc9, 0xdd, 0x83, 0x5d, 0xb9, 0x7f, 0xb0, 0x2b, 0x4f, 0x0f, 0x36, 0xfa, 0x66,
	0x61, 0xa3, 0x9f, 0x17, 0x36, 0xfa, 0x75, 0x61, 0xa3, 0xbb, 0x85, 0x8d, 0xfe, 0x58, 0xd8, 0xe8,
	0xaf, 0x85, 0x5d, 0x79, 0x5a, 0xd8, 0xe8, 0xfb, 0x47, 0xbb, 0x72, 0xf7, 0x68, 0x57, 0xee, 0x1f,
	0xed, 0xca, 0xb5, 0xb3, 0x32, 0xed, 0x8b, 0x94, 0xdd, 0x7e, 0x19, 0x84, 0x23, 0x3f, 0x62, 0x2c,
	0x2a, 0x7c, 0xf9, 0xad, 0x81, 0x29, 0x3d, 0x7c, 0xe7, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9b,
	0x27, 0xc3, 0x26, 0x6a, 0x06, 0x00, 0x00,
}

func (this *GetDetectorsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetDetectorsResponse)
	if !ok {
		that2, ok := that.(GetDetectorsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Detectors) != len(that1.Detectors) {
		return false
	}
	for i := range this.Detectors {
		if !this.Detectors[i].Equal(that1.Detectors[i]) {
			return false
		}
	}
	return true
}
func (this *Detector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Detector)
	if !ok {
		that2, ok := that.(Detector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.Channels != that1.Channels {
		return false
	}
	return true
}
func (this *DetectRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DetectRequest)
	if !ok {
		that2, ok := that.(DetectRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.DetectorName != that1.DetectorName {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.File != that1.File {
		return false
	}
	if len(this.Detect) != len(that1.Detect) {
		return false
	}
	for i := range this.Detect {
		if this.Detect[i] != that1.Detect[i] {
			return false
		}
	}
	if len(this.Regions) != len(that1.Regions) {
		return false
	}
	for i := range this.Regions {
		if !this.Regions[i].Equal(that1.Regions[i]) {
			return false
		}
	}
	return true
}
func (this *DetectRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DetectRegion)
	if !ok {
		that2, ok := that.(DetectRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Top != that1.Top {
		return false
	}
	if this.Left != that1.Left {
		return false
	}
	if this.Bottom != that1.Bottom {
		return false
	}
	if this.Right != that1.Right {
		return false
	}
	if len(this.Detect) != len(that1.Detect) {
		return false
	}
	for i := range this.Detect {
		if this.Detect[i] != that1.Detect[i] {
			return false
		}
	}
	if this.Covers != that1.Covers {
		return false
	}
	return true
}
func (this *Detection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Detection)
	if !ok {
		that2, ok := that.(Detection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Top != that1.Top {
		return false
	}
	if this.Left != that1.Left {
		return false
	}
	if this.Bottom != that1.Bottom {
		return false
	}
	if this.Right != that1.Right {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Confidence != that1.Confidence {
		return false
	}
	return true
}
func (this *DetectResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DetectResponse)
	if !ok {
		that2, ok := that.(DetectResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if len(this.Detections) != len(that1.Detections) {
		return false
	}
	for i := range this.Detections {
		if !this.Detections[i].Equal(that1.Detections[i]) {
			return false
		}
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *GetDetectorsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&odrpc.GetDetectorsResponse{")
	if this.Detectors != nil {
		s = append(s, "Detectors: "+fmt.Sprintf("%#v", this.Detectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Detector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&odrpc.Detector{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "Channels: "+fmt.Sprintf("%#v", this.Channels)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DetectRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&odrpc.DetectRequest{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "DetectorName: "+fmt.Sprintf("%#v", this.DetectorName)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	keysForDetect := make([]string, 0, len(this.Detect))
	for k, _ := range this.Detect {
		keysForDetect = append(keysForDetect, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDetect)
	mapStringForDetect := "map[string]float32{"
	for _, k := range keysForDetect {
		mapStringForDetect += fmt.Sprintf("%#v: %#v,", k, this.Detect[k])
	}
	mapStringForDetect += "}"
	if this.Detect != nil {
		s = append(s, "Detect: "+mapStringForDetect+",\n")
	}
	if this.Regions != nil {
		s = append(s, "Regions: "+fmt.Sprintf("%#v", this.Regions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DetectRegion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&odrpc.DetectRegion{")
	s = append(s, "Top: "+fmt.Sprintf("%#v", this.Top)+",\n")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Bottom: "+fmt.Sprintf("%#v", this.Bottom)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	keysForDetect := make([]string, 0, len(this.Detect))
	for k, _ := range this.Detect {
		keysForDetect = append(keysForDetect, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDetect)
	mapStringForDetect := "map[string]float32{"
	for _, k := range keysForDetect {
		mapStringForDetect += fmt.Sprintf("%#v: %#v,", k, this.Detect[k])
	}
	mapStringForDetect += "}"
	if this.Detect != nil {
		s = append(s, "Detect: "+mapStringForDetect+",\n")
	}
	s = append(s, "Covers: "+fmt.Sprintf("%#v", this.Covers)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Detection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&odrpc.Detection{")
	s = append(s, "Top: "+fmt.Sprintf("%#v", this.Top)+",\n")
	s = append(s, "Left: "+fmt.Sprintf("%#v", this.Left)+",\n")
	s = append(s, "Bottom: "+fmt.Sprintf("%#v", this.Bottom)+",\n")
	s = append(s, "Right: "+fmt.Sprintf("%#v", this.Right)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Confidence: "+fmt.Sprintf("%#v", this.Confidence)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DetectResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&odrpc.DetectResponse{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Detections != nil {
		s = append(s, "Detections: "+fmt.Sprintf("%#v", this.Detections)+",\n")
	}
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRpc(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OdrpcClient is the client API for Odrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OdrpcClient interface {
	// Get Config
	GetDetectors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetDetectorsResponse, error)
	// Process an request
	Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectResponse, error)
	// Process stream requests
	DetectStream(ctx context.Context, opts ...grpc.CallOption) (Odrpc_DetectStreamClient, error)
}

type odrpcClient struct {
	cc *grpc.ClientConn
}

func NewOdrpcClient(cc *grpc.ClientConn) OdrpcClient {
	return &odrpcClient{cc}
}

func (c *odrpcClient) GetDetectors(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetDetectorsResponse, error) {
	out := new(GetDetectorsResponse)
	err := c.cc.Invoke(ctx, "/odrpc.odrpc/GetDetectors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *odrpcClient) Detect(ctx context.Context, in *DetectRequest, opts ...grpc.CallOption) (*DetectResponse, error) {
	out := new(DetectResponse)
	err := c.cc.Invoke(ctx, "/odrpc.odrpc/Detect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *odrpcClient) DetectStream(ctx context.Context, opts ...grpc.CallOption) (Odrpc_DetectStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Odrpc_serviceDesc.Streams[0], "/odrpc.odrpc/DetectStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &odrpcDetectStreamClient{stream}
	return x, nil
}

type Odrpc_DetectStreamClient interface {
	Send(*DetectRequest) error
	Recv() (*DetectResponse, error)
	grpc.ClientStream
}

type odrpcDetectStreamClient struct {
	grpc.ClientStream
}

func (x *odrpcDetectStreamClient) Send(m *DetectRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *odrpcDetectStreamClient) Recv() (*DetectResponse, error) {
	m := new(DetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OdrpcServer is the server API for Odrpc service.
type OdrpcServer interface {
	// Get Config
	GetDetectors(context.Context, *empty.Empty) (*GetDetectorsResponse, error)
	// Process an request
	Detect(context.Context, *DetectRequest) (*DetectResponse, error)
	// Process stream requests
	DetectStream(Odrpc_DetectStreamServer) error
}

func RegisterOdrpcServer(s *grpc.Server, srv OdrpcServer) {
	s.RegisterService(&_Odrpc_serviceDesc, srv)
}

func _Odrpc_GetDetectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OdrpcServer).GetDetectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/odrpc.odrpc/GetDetectors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OdrpcServer).GetDetectors(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Odrpc_Detect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OdrpcServer).Detect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/odrpc.odrpc/Detect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OdrpcServer).Detect(ctx, req.(*DetectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Odrpc_DetectStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OdrpcServer).DetectStream(&odrpcDetectStreamServer{stream})
}

type Odrpc_DetectStreamServer interface {
	Send(*DetectResponse) error
	Recv() (*DetectRequest, error)
	grpc.ServerStream
}

type odrpcDetectStreamServer struct {
	grpc.ServerStream
}

func (x *odrpcDetectStreamServer) Send(m *DetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *odrpcDetectStreamServer) Recv() (*DetectRequest, error) {
	m := new(DetectRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Odrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "odrpc.odrpc",
	HandlerType: (*OdrpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDetectors",
			Handler:    _Odrpc_GetDetectors_Handler,
		},
		{
			MethodName: "Detect",
			Handler:    _Odrpc_Detect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DetectStream",
			Handler:       _Odrpc_DetectStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "odrpc/rpc.proto",
}

func (m *GetDetectorsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDetectorsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Detectors) > 0 {
		for _, msg := range m.Detectors {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Detector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Model) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Model)))
		i += copy(dAtA[i:], m.Model)
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Width != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Height))
	}
	if m.Channels != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRpc(dAtA, i, uint64(m.Channels))
	}
	return i, nil
}

func (m *DetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.DetectorName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.DetectorName)))
		i += copy(dAtA[i:], m.DetectorName)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if len(m.Detect) > 0 {
		for k, _ := range m.Detect {
			dAtA[i] = 0x2a
			i++
			v := m.Detect[k]
			mapSize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + 4
			i = encodeVarintRpc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i += 4
		}
	}
	if len(m.Regions) > 0 {
		for _, msg := range m.Regions {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DetectRegion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectRegion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Top != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Top))))
		i += 4
	}
	if m.Left != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Left))))
		i += 4
	}
	if m.Bottom != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Bottom))))
		i += 4
	}
	if m.Right != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Right))))
		i += 4
	}
	if len(m.Detect) > 0 {
		for k, _ := range m.Detect {
			dAtA[i] = 0x2a
			i++
			v := m.Detect[k]
			mapSize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + 4
			i = encodeVarintRpc(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpc(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x15
			i++
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(v))))
			i += 4
		}
	}
	if m.Covers {
		dAtA[i] = 0x30
		i++
		if m.Covers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Detection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Top != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Top))))
		i += 4
	}
	if m.Left != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Left))))
		i += 4
	}
	if m.Bottom != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Bottom))))
		i += 4
	}
	if m.Right != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Right))))
		i += 4
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Confidence != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Confidence))))
		i += 4
	}
	return i, nil
}

func (m *DetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Detections) > 0 {
		for _, msg := range m.Detections {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetDetectorsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Detectors) > 0 {
		for _, e := range m.Detectors {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *Detector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.Width != 0 {
		n += 1 + sovRpc(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovRpc(uint64(m.Height))
	}
	if m.Channels != 0 {
		n += 1 + sovRpc(uint64(m.Channels))
	}
	return n
}

func (m *DetectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.DetectorName)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Detect) > 0 {
		for k, v := range m.Detect {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovRpc(uint64(mapEntrySize))
		}
	}
	if len(m.Regions) > 0 {
		for _, e := range m.Regions {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	return n
}

func (m *DetectRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Top != 0 {
		n += 5
	}
	if m.Left != 0 {
		n += 5
	}
	if m.Bottom != 0 {
		n += 5
	}
	if m.Right != 0 {
		n += 5
	}
	if len(m.Detect) > 0 {
		for k, v := range m.Detect {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRpc(uint64(len(k))) + 1 + 4
			n += mapEntrySize + 1 + sovRpc(uint64(mapEntrySize))
		}
	}
	if m.Covers {
		n += 2
	}
	return n
}

func (m *Detection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Top != 0 {
		n += 5
	}
	if m.Left != 0 {
		n += 5
	}
	if m.Bottom != 0 {
		n += 5
	}
	if m.Right != 0 {
		n += 5
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.Confidence != 0 {
		n += 5
	}
	return n
}

func (m *DetectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if len(m.Detections) > 0 {
		for _, e := range m.Detections {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	return n
}

func sovRpc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetDetectorsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetDetectorsResponse{`,
		`Detectors:` + strings.Replace(fmt.Sprintf("%v", this.Detectors), "Detector", "Detector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Detector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Detector{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Labels:` + fmt.Sprintf("%v", this.Labels) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`Channels:` + fmt.Sprintf("%v", this.Channels) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DetectRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForDetect := make([]string, 0, len(this.Detect))
	for k, _ := range this.Detect {
		keysForDetect = append(keysForDetect, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDetect)
	mapStringForDetect := "map[string]float32{"
	for _, k := range keysForDetect {
		mapStringForDetect += fmt.Sprintf("%v: %v,", k, this.Detect[k])
	}
	mapStringForDetect += "}"
	s := strings.Join([]string{`&DetectRequest{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`DetectorName:` + fmt.Sprintf("%v", this.DetectorName) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`File:` + fmt.Sprintf("%v", this.File) + `,`,
		`Detect:` + mapStringForDetect + `,`,
		`Regions:` + strings.Replace(fmt.Sprintf("%v", this.Regions), "DetectRegion", "DetectRegion", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DetectRegion) String() string {
	if this == nil {
		return "nil"
	}
	keysForDetect := make([]string, 0, len(this.Detect))
	for k, _ := range this.Detect {
		keysForDetect = append(keysForDetect, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDetect)
	mapStringForDetect := "map[string]float32{"
	for _, k := range keysForDetect {
		mapStringForDetect += fmt.Sprintf("%v: %v,", k, this.Detect[k])
	}
	mapStringForDetect += "}"
	s := strings.Join([]string{`&DetectRegion{`,
		`Top:` + fmt.Sprintf("%v", this.Top) + `,`,
		`Left:` + fmt.Sprintf("%v", this.Left) + `,`,
		`Bottom:` + fmt.Sprintf("%v", this.Bottom) + `,`,
		`Right:` + fmt.Sprintf("%v", this.Right) + `,`,
		`Detect:` + mapStringForDetect + `,`,
		`Covers:` + fmt.Sprintf("%v", this.Covers) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Detection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Detection{`,
		`Top:` + fmt.Sprintf("%v", this.Top) + `,`,
		`Left:` + fmt.Sprintf("%v", this.Left) + `,`,
		`Bottom:` + fmt.Sprintf("%v", this.Bottom) + `,`,
		`Right:` + fmt.Sprintf("%v", this.Right) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Confidence:` + fmt.Sprintf("%v", this.Confidence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DetectResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DetectResponse{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Detections:` + strings.Replace(fmt.Sprintf("%v", this.Detections), "Detection", "Detection", 1) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringRpc(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetDetectorsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDetectorsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDetectorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detectors = append(m.Detectors, &Detector{})
			if err := m.Detectors[len(m.Detectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			m.Channels = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channels |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetectorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detect == nil {
				m.Detect = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Detect[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, &DetectRegion{})
			if err := m.Regions[len(m.Regions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectRegion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectRegion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectRegion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Top = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Left = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Bottom = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Right = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detect == nil {
				m.Detect = make(map[string]float32)
			}
			var mapkey string
			var mapvalue float32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRpc
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					mapvalue = math.Float32frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpc(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRpc
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Detect[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Covers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Covers = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Top", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Top = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Left = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bottom", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Bottom = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Right = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Confidence = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detections = append(m.Detections, &Detection{})
			if err := m.Detections[len(m.Detections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRpc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRpc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc   = fmt.Errorf("proto: integer overflow")
)
